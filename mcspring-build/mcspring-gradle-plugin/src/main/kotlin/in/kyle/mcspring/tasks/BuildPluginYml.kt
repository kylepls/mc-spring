package `in`.kyle.mcspring.tasks

import `in`.kyle.mcspring.annotation.PluginDepend
import `in`.kyle.mcspring.annotation.SoftPluginDepend
import `in`.kyle.mcspring.commands.dsl.mcspring.Command
import `in`.kyle.mcspring.div
import `in`.kyle.mcspring.getMainSourceSet
import `in`.kyle.mcspring.mcspring
import io.github.classgraph.ClassGraph
import org.apache.log4j.Logger
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction
import org.yaml.snakeyaml.Yaml
import java.io.File
import java.net.URLClassLoader
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import kotlin.reflect.KClass

open class BuildPluginYml : DefaultTask() {

    private val logger = Logger.getLogger(BuildPluginYml::class.java)
    private val attributes = mutableMapOf<String, Any>()

    @TaskAction
    fun buildYml() {
        val props = project.extensions.mcspring

        props.apply {
            attributes["name"] = pluginName ?: project.name
            attributes["version"] = pluginVersion ?: project.version
            attributes["main"] = "$pluginMainPackage.SpringJavaPlugin"

            fun writeNonNull(key: String, value: Any?) = value?.apply { attributes[key] = this }

            writeNonNull("description", pluginDescription)
            writeNonNull("load", pluginLoad?.toString()?.toLowerCase())
            writeNonNull("author", pluginAuthor)
            writeNonNull("authors", pluginAuthors)
            writeNonNull("website", pluginWebsite)
            writeNonNull("database", pluginDatabase)
            writeNonNull("prefix", pluginPrefix)
            writeNonNull("loadbefore", pluginLoadBefore)
        }

        project.getMainSourceSet().runtimeClasspath.files.apply {
            addDependencies(this)
            addCommands(this)
        }

        writeYmlFile()
    }

    private fun writeYmlFile() {
        val outputFile = project.buildDir / "resources" / "main"
        outputFile.mkdirs()
        val pluginYml = outputFile / "plugin.yml"
        logger.info("Building to $pluginYml")

        val formatter = DateTimeFormatter.ofPattern("YYYY-MM-dd HH:mm:SS")
        val nowFormatted = LocalDateTime.now().format(formatter)
        pluginYml.appendText("""
                # File auto generated by mcspring on $nowFormatted
                # https://github.com/kylepls/mcspring
                
            """.trimIndent())
        pluginYml.appendText(Yaml().dumpAsMap(attributes))
    }

    private fun addDependencies(files: Set<File>) {
        val classLoader = URLClassLoader(files.map { it.toURI().toURL() }.toTypedArray())
        val scanResult = ClassGraph()
                .overrideClassLoaders(classLoader)
                .enableAnnotationInfo()
                .scan()
        scanResult.use {
            fun getPluginDependencies(annotation: String) =
                    scanResult.allClasses.filter { it.isStandardClass && it.hasAnnotation(annotation) }
                            .map { it.getAnnotationInfo(annotation).parameterValues }
                            .flatMap { (it["plugins"].value as Array<String>).toList() }

            fun addAnnotationAttributeList(string: String, clazz: KClass<*>) =
                    getPluginDependencies(clazz.qualifiedName!!)
                            .takeIf { it.isNotEmpty() }
                            ?.apply { attributes[string] = this }

            addAnnotationAttributeList("softdepend", SoftPluginDepend::class)
            addAnnotationAttributeList("depend", PluginDepend::class)
        }
    }

    private fun addCommands(files: Set<File>) {
        val classLoader = URLClassLoader(files.map { it.toURI().toURL() }.toTypedArray())
        val scanResult = ClassGraph()
                .overrideClassLoaders(classLoader)
                .enableAnnotationInfo()
                .enableMethodInfo()
                .enableClassInfo()
                .scan()

        val annotations = scanResult.use {
            fun getAnnotations(annotation: KClass<*>) =
                    scanResult.getClassesWithMethodAnnotation(annotation.qualifiedName!!)
                            .flatMap { it.methodInfo.filter { it.hasAnnotation(annotation.qualifiedName!!) } }
                            .map { it.getAnnotationInfo(annotation.qualifiedName!!) }
                            .map { it.parameterValues }

            getAnnotations(Command::class)
        }

        val commands = annotations.map {
            val meta = mutableMapOf<String, Any>()

            meta["description"] = it.getValue("description")
            meta["aliases"] = it.getValue("aliases")
            meta["permission"] = it.getValue("permission")
            meta["permission-message"] = it.getValue("permissionMessage")
            meta["usage"] = it.getValue("usage")

            val name = it["value"].value
            val filteredMeta = meta.filterValues { value ->
                when (value) {
                    is Array<*> -> value.isNotEmpty()
                    is String -> value.isNotEmpty()
                    else -> true
                }
            }
            Pair(name, filteredMeta)
        }.associate { it }

        if (commands.isNotEmpty()) {
            attributes["commands"] = commands
        }
    }
}
